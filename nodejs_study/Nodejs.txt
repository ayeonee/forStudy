*모듈 : 노드로 개발한 애플리케이션을 이루는 기본 단위, 관련 코드들을 모아서 캡슐화해놓은 것
	모듈 단위로 구성된다 = 객체 지향 컨셉으로 애플리케이션이 구성
 -전역 객체 : 어디서나 사용할 수 있는 객체
 -모듈의 종류 
  기본 모듈 & 확장 모듈 : 기본은 노드를 설치하면 기본으로 설치되는 모듈, 확장은 노드의 기능을 확장시킴(express처럼 하나의 프레임워크로서 제공되기도 하고 다른 기술을 손쉽게 끌어와 사용할 수 있게 도와줌)
  일반 모듈 & 네이티브 모듈 : 개발방법에 따라 나눌 수 있음. C/C++로 노드의 모듈을 개발한 경우 네이티브 모듈, 일반 모듈은 자바스크립트로 개발된 모듈. 같은 기능을 수행한다면 네이티브 모듈이 더나은 성능
  글로벌 모듈 & 로컬 모듈 : 어디서든 사용할 수 있도록 설치한 확장 모듈을 글로벌 모듈, 해당 애플리케이션에서만 사용하기 위해 설치한 확장 모듈이나 개발자가 개발한 모듈을 로컬 모듈.
  복합 모듈 : 내부 모듈이나 데이터 파일, 템플릿, 테스트 코드 등을 포함하는 모듈
  require() : 앞으로 모듈을 불러올 때 사용, 모듈 식별자인 module.exports를 이용해 모듈이 제공하는 함수나 객체를 반환. 불러온 모듈이 다른 모듈이 잇어야 한다면 그 모듈도 같이 로드함. 

*전역 객체 ; Global
 -console : 콘솔화면과 관련된 기능. log와 time 자주 씀. console.log(), console.time(label) : 시간 측정 시작, console.timeEnd(label) : 시간 측정 종료
 -process : 프로그램과 관련된 기능을 다루는 객체. 
	process.argv: 프로그램의 매개변수 정보
	process.env : 컴퓨터 환경과 관련된 정보
	process.version : Node.js의 버전
	process.versions : Node.js 프로세스에서 사용하는 모듈들의 버전
	process.arch : 프로세서의 아키텍처
	process.platform : 플랫폼의 정보
	process.exit() : 프로그램 종료
	process.memoryUsage() : 메모리 사용 정보
	process.uptime() : 현재 프로그램이 실행된 시간
 -exports : 모듈 관련 객체, exports 사용하여 기능 확장 가능. 

*Utility 모듈 : node.js의 보조적인 기능 중 유용한 기능만을 모아놓은 모듈.
*file system  모듈 : 파일 처리와 관련된 작업을 하는 모듈. sync라는 이름이 붙어있는 메소드가 동기방식 사용. 동기적 읽기 방식 사용하면 파일을 읽으면서 다른 작업 동시에 할수 없음. 비동기적으로 읽으면 파일을 읽으면서 다른 작업도 동시에 수행 가능, 파일을 다 읽으면 매개변수 callback으로 전달된 함수가 호출됨.
*event 모듈 : 노드의 객체가 이벤트 발생시킬 때 이러한 객체들은 events.EventEmitter라는 인스턴스 이용. 
	node.js에서는 이벤트 모듈과 EventEmitter클래스가 내장되어 있는데, 이를 사용하여 이벤트와 에빈트 핸들러를 연동시킬 수 있음. 이벤트를 활용하는 객체에는 해당 이벤트가 발생할 때 대응하여 동작하는 콜백 함수를 가지는데 이러한 함수를 이벤트 리스너라고 부르기도 함. 이벤트 모듈을 사용하려면 require() 메소드를 이용하여 로드하고, 그 객체를 통해 EventEmitter 클래스를 로드하여 사용하는 것이 일반적

*노드에서의 상속 : 자바스크립트와 동일하게 상속할 수 있지만 더 편리하게 상속할수 있도록 util모듈 통해 별도의 메소드 지원.(util.inherits())

*확장모듈 (https://www.npmjs.com/ npm registry 사이트)
 설치 npm install [모듈명] -g
 확인 npm list -g
 여러개 설치 npm install [모듈1], [모듈2], [모듈3]
 특정 버전의 확장모듈 설치 npm install [모듈명@버전]
 업데이트 npm update [모듈명] or npm update [모듈명] -g
 모든 모듈 업데이트 npm update
 모듈 삭제 npm uninstall [모듈명] or npm uninstall [모듈명] -g
 
*package.json : 배포한 모듈 정보를 담고자 만들었지만, 노드로 작성하는 애플리케이션도 관리 가능.
 직접 작성도 가능하지만 npm init 으로 자동 생성 가능. 해당 애플리케이션을 위해 사용한 확장 모듈에 대한 정보는 npm install -save 를 통해 자동으로 모듈 정보 추가 가능.
 pacakge.json 파일 내용과 설명 : https://edu.goorm.io/learn/lecture/557/%ED%95%9C-%EB%88%88%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-node-js/lesson/174371/package-json

*nodemon : 노드가 실행하는 파일이 속한 디렉터리를 감시하고 있다가 파일이 수정되면 자동으로 노드 애플리케이션으 재시작하는 확장 모듈. 
 설치 : npm install nodemon -g (노드 애플리케이션 개발할 때마다 사용할 예정)
 사용법 : nodemon app.js

*express 설치
	npm install -g express-generator
	express [디렉토리 명]
	(에러 뜨면 window shell 에서 권한 수정)
	npm start 하면 서버 시작
	http://localhost:3000/ 로 접속
	ctrl c로 종료 가능

express 설치 후 생성된 파일 중에 실행에 가장 큰 영향 미치는 것(app.js와 www)
*app.js 내부 구성 
 1~8번 : 모듈 불러옴. 5번 morgan은 http 리퀘스트에 대해 로깅, 객체를 생성. 10번 app 객체 선언하고 express() 함수로 생성. 이 객체로 웹 서버의 특징을 기술.
 13번 : 화면을 보이게 할 뷰 템플릿 파일들이 있는 경로를 라우팅하기 위해 그 값을 미리 정의. 화면의 출력을 담당하는 뷰계층을 구성하는 파일들을 연결. (views 폴더로 지정) 앞으로 뷰 템플릿 파일을 만들고 난 후 views 폴더 안에 넣어주고 라우팅 설정해주면 됨. (*라우팅 : 클라이언트로부터 요청받은 URL과 뷰를 매칭시키는 것)
 14번 : 뷰에 사용될 기본 엔진의 이름을 정의. 
 20번 : 디렉토리 구조를 URL에 반영하여 쉽게 접근 가능한 정적 디렉토리를 설정함.
 31~40번 : 에러 발생했을 때 어떻게 처리할지에 대한 코드 
*www.js 
 http에 관한 설정. (웹 서버와 관련된 부분이 들어있음) npm start도 이 www 파일을 실행시킴. 
 var port = normalizePort(process.env.PORT || '3000'); 포트 값 설정.

*페이지 라우팅 : 특정한 URL에 대해 특정한 뷰로 연결하는 역할. 실제로 라우팅에 사용되는 정보는 호스트 이름을 제외하고 나머지 경로를 표시한 문자. (ex. http://localhost:3000/hello 면 라우팅 대상은 '/hello'
	app.get('/', function(req, res){
		res.render('index.jade');
	});
	app.get 함수는 GET방식으로 들어오는 경로를 연결, 이에 대응하는 동작을 콜백함수로 기술할 수 있도록 함. 지정된 Path인 '/' 은 웹 사이트의 루트 페이지로 연결.
	req=요청 객체, 클라이언트에서 보낸 여러 정보가 포함. 
	res=응답 객체, 우리가 클라이언트에 응답할 수 있게 하는 객체. render()로 뷰를 렌더링함.
	jade : 템플릿 엔진 모듈.
	app.post 함수는 POST 방식으로 들어오는 경로를 연결. 
	app.post('/post', function(req, res){
		res.render('write.jade', {
			id : req.body.id,
			name : req.body.name
		});
	})
	id, name이라는 HTML Form의 item으로 넘어온 값을 전달하여 출력. 
	app.get('/hello/:id', function(req,res){
		var id = req.params.id;
		~~
	}); 이고 http://localhost:3000/hello/world 로 요청받았다면 req.params.id에는 'world'라는 문자열이 들어감.
	